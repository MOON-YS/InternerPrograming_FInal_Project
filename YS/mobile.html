<!DOCTYPE html>
 <html>
 <head>
   <meta charset="utf-8">
   <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no,target-densitydpi=medium-dpi" />
   <meta name="apple-mobile-web-app-capable" content="no" />
   <meta name="apple-mobile-web-app-status-bar-style" content="black" />
   <title>JeongHun</title>
   <style>
      html {
        scroll-behavior: smooth;
      }
      ul {
        margin:0;
        padding:0;
        list-style-type: none;
      }

      #loadingScreen {
        display:block;
        position: absolute;
        top:-6%;
        left:0;
        z-index:2;
        width: 100%;
        height: 120%;
        margin: 0 auto;
        background-color: #EAEAEA;
        text-align: center;
       
      }
      #loadingPercent{
        font-weight: 300;
        font-size:20px;
        margin-top:5%;
      }

      #loadingImage {
        width: 100px;
        height: 100px;
        display: block;
        margin: 0 auto;
        margin-top: 50%;
      }
      #background {
        width: 90%;
        height: 0px;
        margin: 0 auto;
      }
      #dropdown{
        display : none;
        width: 100%;
        height: 5%;
        margin: 0 auto;
        background-color: #113a6b;
      }
      #ButtonImage {
        display: block;
        width:40px;
        height: 90%;
        float:left ;
        margin-top: 2px;
        margin-left : 5px;
        padding-bottom : 0px;
        cursor:pointer;
        border-radius: 100%;
        transition:all ease 1s;
        box-shadow: 2px 2px 2px gray;
        background-color: #EAEAEA;
        text-align: center;
        font-weight: bold;
        font-size: 13px;
      }
      #ButtonImage p, #nowPlaying p {
        margin-top:10px
      }
      

      #main {
        position: relative;
        width: 100%;
        height: 85%;
        margin: 0 auto;
        background-color: antiquewhite; 
        transition:all ease 0.5s;
      }
      #hiddenList {
        position: absolute;
        top:0;
        left:0;
        z-index:1;
        background-color: white;
        background-color:rgba(0, 0, 0, 0.5);/*까만색(0,0,0) 20% 투명도*/
        width: 0%;
        height: 100%;
        margin: 0;
        padding:0;
        transition:all ease 0.5s;
      }
      .test_obj input[type="radio"] {
        display: none;
    }
 
    .test_obj input[type="radio"] + span {  
        margin-left: 10px;
        width:98px;
        height: 20px;
        display: block;
        padding: 15px 10px;
        border: 1px solid #dfdfdf;
        background-color: #ffffff;
        text-align: center;
        cursor: pointer;
        margin-top:5px;
    }
 
    .test_obj input[type="radio"]:checked + span {
        background-color: #113a6b;
        color: #ffffff;
    }
    .test_obj input[type="radio"] + span:hover {
      background-color: #113a6b;
      color: #ffffff;
    }
      

      #hiddenList_content_ul {
       display: none;
       opacity: 0;
       transition:all ease 0.5s;
       width: 98px;
       font-weight: 500;
      }

      #main #main_section1 {
        position: absolute;
        top:0;
        left:0;
        z-index:0;
        width: 100%;
        height: 100%;
        margin: 0 auto;
        transition:all ease 0.5s;
      }
      #main #map {
        display : block;
        width: 100%;
        height: 77%;
        margin: 0 auto;
      }

      #main #scrollBar {
        width:100%; height:22%; overflow-x:auto; white-space:nowrap; margin:0 auto;   
        border-bottom-left-radius: 10px;
        border-bottom-right-radius: 10px;
        background-color: lightblue;
        white-space: nowrap;  
      }
      

      #footer {
        display:none;
        z-index:1;
        width: 100%;
        height: 10%;
        background-color: #113a6b;
      
      }
      #naviIcon, #mapIcon, #reservationIcon{
        display: block;
        float:left;
        margin-top:15px;
        width: 60px;
        height: 60px;
        margin-left:10%;
        background-color: #EAEAEA;
        border-radius: 100%;
        cursor:pointer;
        text-align: center;
        transition:all ease 0.5s;
      }



      #scrollBar > ul { font-size:0px; text-overflow : scroll;}
      #scrollBar > ul > li {
        display:inline-block; 
        font-size:10px; 
        text-align: center;
        width:30%; height:100px; 
        background:#EAEAEA;
        overflow-x:auto; white-space:nowrap;
        margin-right:10px;
        padding-top:20px;
      }
      #performanceDetailInformation {
        overflow-y:auto; overflow-X:auto; white-space:nowrap;
        word-break:break-all;
        width: 0px;
        height: 0px;
        margin: 0 auto;
        margin-top : 20px;
        margin-right: 0px;
        border-radius: 20%;
        text-align: center;
        background-color: #BCE55C;
        box-shadow: 20px 20px 20px gray;
        transition:all ease 0.5s;
        font-size:15px;
        font-weight: 900;
        letter-spacing:-0.5px;
      }

      #performanceDetailInformation:hover{
        background-color: #EAEAEA;
      }
      #performanceDetailInformation h4 {
        margin-bottom: 5px;
        font-weight: bold;
      }
      #performanceDetailInformation h5 {
        margin-bottom: 5px;
      }
      

      #dateDesignation {
        margin-top:3%;
        margin-left: 10%;
        cursor:pointer;
        transition:all ease 1s;
        box-shadow: 2px 2px 2px gray;
        background-color: #EAEAEA;
      }
      #dataDesignation_send {
        margin-top:3%;
        cursor:pointer;
        transition:all ease 1s;
        box-shadow: 2px 2px 2px gray;
        background-color: #EAEAEA;
      }
      #nowPlaying {
        display: block;
        width:40px;
        height: 90%;
        float:left ;
        margin-top: 2px;
        margin-left:8px;
        margin-right : 5px;
        padding-bottom : 0px;
        cursor:pointer;
        border-radius: 100%;
        transition:all ease 1s;
        box-shadow: 2px 2px 2px gray;
        background-color: #EAEAEA;
        text-align: center;
        font-weight: bold;
        font-size: 9px;
      }
   </style>
 </head>
 <body>
   <div id = "background">
     <header id ="dropdown">
      <div id = "ButtonImage"><p>menu</p></div>
      <div class = "false" id ="nowPlaying" style = "width:40px;"><p style="display: block; margin-top:12px">Playing..</p></div>
      <input class = "false" id = "dateDesignation" type='date'>
      <input class = "false" id = "dataDesignation_send" type ="submit" value="확인">
     </header>
     <main id = "main">
       <div id="loadingScreen">
         <img id = "loadingImage" src = "http://mpv990422.duckdns.org/imgs/Spinner.gif">
         <p id="loadingPercent">waiting...</p> 
       </div>
       <div id = "hiddenList">
          <ul id = "hiddenList_content_ul">
            <li><label class="test_obj"><input id = "checkMusical" type="radio" name="radioButton" value="musical" checked><span>뮤지컬</span></label></li>
            <li><label class="test_obj"><input id = "checkOpera" type="radio" name="radioButton" value="opera"><span>오페라</span></label></li>
            <li><label class="test_obj"><input id = "checkPlay" type="radio" name="radioButton" value="play"><span>연극</span></label></li>
            <li><label class="test_obj"><input id = "checkConcert" type="radio" name="radioButton" value="concert"><span>콘서트</span></label></li>
            <li><label class="test_obj"><input id = "checkTraditionalArt" type="radio" name="radioButton" value="traditionalArt"><span>전통 예술</span></label></li>
            <li><label class="test_obj"><input id = "checkClassic" type="radio" name="radioButton" value="classic"><span>클래식</span></label></li>
            <li><label class="test_obj"><input id = "checkExhibition" type="radio" name="radioButton" value="exhibition"><span>전시</span></label></li>
            <li><label class="test_obj"><input id = "checkDance" type="radio" name="radioButton" value="dance"><span>무용</span></label></li>
          </ul>
       </div>
       <section id = "main_section1">
         <div id = "map">
         </div>
         <div id = "scrollBar">
            <ul id = "scrollBar_ul"></ul>
         </div>
         <div id = "performanceDetailInformation"></div>
       </section>
      
     </main>
     <footer id ="footer">
       <div id ="naviIcon"><p style="font-size: 13px;font-weight: bold;margin-top: 15px;">카카오<br>네비</p></div>
       <div id ="mapIcon"><p style="font-size: 14px;font-weight: bold;margin-top: 20px;">카카오맵</p></div>
       <div id ='reservationIcon'><p style="font-size: 15px;font-weight: bold;margin-top: 20px;">예매</p></div>
      </footer>
   </div>
   
   <script type="text/javascript" src = "https://dapi.kakao.com/v2/maps/sdk.js?appkey=3f5d2674c29eb3cb86007a28668890f6&libraries=services"></script>
   <script type="text/javascript" src = "https://developers.kakao.com/sdk/js/kakao.js"></script>
   <script>
     //모바일 해상도 설정하는데 현재 사용자의 모바일 환경의 높이를 가져와 배경화면에 해당하는 div태그의 height를 설정.
      var background = document.querySelector('#background');
      background.style.height = `${screen.height}px`;
   </script>

   <script>
        //--------------------변수 선언-------------------
        const themcode =    'https://moonjeonghunapp1.herokuapp.com/http://apis.data.go.kr/6260000/BusanCultureThemeCodeService/getBusanCultureThemeCode?serviceKey=5WFmQsUZpTifa4SpNtPI1z1RqC721HbHHo937DJt9NYV1lr50bhm15x7cpREJ14DSBtNtOm5C3Oz0CFckeUeAA%3D%3D&pageNo=1&numOfRows=1000&resultType=json';
        const place =       'https://moonjeonghunapp1.herokuapp.com/http://apis.data.go.kr/6260000/BusanCulturePerformPlaceService/getBusanCulturePerformPlace?serviceKey=5WFmQsUZpTifa4SpNtPI1z1RqC721HbHHo937DJt9NYV1lr50bhm15x7cpREJ14DSBtNtOm5C3Oz0CFckeUeAA%3D%3D&pageNo=1&numOfRows=1000&resultType=json'

        //전체 8개의 공연이 있으며, 공연 8개의 Json정보를 가져오는 변수
        const musicalJson =        'https://moonjeonghunapp1.herokuapp.com/http://apis.data.go.kr/6260000/BusanCultureMusicalDetailService/getBusanCultureMusicalDetail?serviceKey=5WFmQsUZpTifa4SpNtPI1z1RqC721HbHHo937DJt9NYV1lr50bhm15x7cpREJ14DSBtNtOm5C3Oz0CFckeUeAA%3D%3D&pageNo=1&numOfRows=1000&resultType=json';
        const operaJson =          'https://moonjeonghunapp1.herokuapp.com/http://apis.data.go.kr/6260000/BusanCultureOperaDetailService/getBusanCultureOperaDetail?serviceKey=5WFmQsUZpTifa4SpNtPI1z1RqC721HbHHo937DJt9NYV1lr50bhm15x7cpREJ14DSBtNtOm5C3Oz0CFckeUeAA%3D%3D&pageNo=1&numOfRows=1000&resultType=json';
        const playJson =           'https://moonjeonghunapp1.herokuapp.com/http://apis.data.go.kr/6260000/BusanCulturePlayDetailService/getBusanCulturePlayDetail?serviceKey=5WFmQsUZpTifa4SpNtPI1z1RqC721HbHHo937DJt9NYV1lr50bhm15x7cpREJ14DSBtNtOm5C3Oz0CFckeUeAA%3D%3D&pageNo=1&numOfRows=1000&resultType=json'
        const concertJson =        'https://moonjeonghunapp1.herokuapp.com/http://apis.data.go.kr/6260000/BusanCultureConcertDetailService/getBusanCultureConcertDetail?serviceKey=5WFmQsUZpTifa4SpNtPI1z1RqC721HbHHo937DJt9NYV1lr50bhm15x7cpREJ14DSBtNtOm5C3Oz0CFckeUeAA%3D%3D&pageNo=1&numOfRows=1000&resultType=json'
        const traditionalArtJson = 'https://moonjeonghunapp1.herokuapp.com/http://apis.data.go.kr/6260000/BusanCultureTraditionDetailService/getBusanCultureTraditionDetail?serviceKey=5WFmQsUZpTifa4SpNtPI1z1RqC721HbHHo937DJt9NYV1lr50bhm15x7cpREJ14DSBtNtOm5C3Oz0CFckeUeAA%3D%3D&pageNo=1&numOfRows=1000&resultType=json'
        const classicJson =        'https://moonjeonghunapp1.herokuapp.com/http://apis.data.go.kr/6260000/BusanCultureClassicDetailService/getBusanCultureClassicDetail?serviceKey=5WFmQsUZpTifa4SpNtPI1z1RqC721HbHHo937DJt9NYV1lr50bhm15x7cpREJ14DSBtNtOm5C3Oz0CFckeUeAA%3D%3D&pageNo=1&numOfRows=1000&resultType=json';
        const exhibitionJson =     'https://moonjeonghunapp1.herokuapp.com/http://apis.data.go.kr/6260000/BusanCultureExhibitDetailService/getBusanCultureExhibitDetail?serviceKey=5WFmQsUZpTifa4SpNtPI1z1RqC721HbHHo937DJt9NYV1lr50bhm15x7cpREJ14DSBtNtOm5C3Oz0CFckeUeAA%3D%3D&stdt=2021&pageNo=1&numOfRows=1000&resultType=json';
        const danceJson =          'https://moonjeonghunapp1.herokuapp.com/http://apis.data.go.kr/6260000/BusanCultureDanceDetailService/getBusanCultureDanceDetail?serviceKey=5WFmQsUZpTifa4SpNtPI1z1RqC721HbHHo937DJt9NYV1lr50bhm15x7cpREJ14DSBtNtOm5C3Oz0CFckeUeAA%3D%3D&pageNo=1&numOfRows=1000&resultType=json';
        const parkJson =           'https://moonjeonghunapp1.herokuapp.com/http://apis.data.go.kr/6260000/BusanPblcPrkngInfoService/getPblcPrkngInfo?serviceKey=5WFmQsUZpTifa4SpNtPI1z1RqC721HbHHo937DJt9NYV1lr50bhm15x7cpREJ14DSBtNtOm5C3Oz0CFckeUeAA%3D%3D&pageNo=1&numOfRows=1000&resultType=json'
       
        //xxxInformation 변수는 Json에서 공연 정보를 가져와 해당 객체를 배열화 함, xxxMarker 변수는 공연의 마커정보의 객체르 배열화 함.
        var today = getToday();             //현재 날짜 yyyy-mm-dd 형태 반환
        var placeInformation= [];           //공연장 장소 저장
        var musicalInformation = [];         //뮤지컬 Json 정보 저장
        var musicalMarker = [];             //뮤지컬 마커 정보 저장
        var operaInformation = [];          //오페라 Josn 정보 저장
        var operaMarker = [];               //오페라 마커 정보 저장
        var playInformation = [];           //연극 Json 정보 저장
        var playMarker = [];                //연극 마커 정보 저장
        var concertInformation = [];        //콘서트 Json 정보 저장
        var concertMarker = [];             //콘서트 마커 저장
        var traditionalArtInformation = []; //전통 예술 Json 정보 저장
        var traditionalArtMarker = [];      //전통 예술 마커 정보 저장
        var classicInformation = [];        //클래식 Json 정보 저장
        var classicMarker = [];             //클래식 마커 정보 저장
        var exhibitionInformation = [];     //전시 Json 정보 저장
        var exhibitionMarker = [];          //전시 마커 저장
        var danceInformation = [];          //무용 Json 정보 저장
        var danceMarker = [];               //무용 마커 정보 저장 

        var totalPark = []; //주차장 Json에서 가져온 객체를 모두 저장하는 배열
        var clickPark = []; //사용자가 클릭한 공연(ex 뮤지컬 노트르담)을 기준으로 1km반경 내에 보여줄 주차장 객체 저장할 배열
        var clickParkMarker = []; //사용자가 클릭한 공연(ex 뮤지컬 노트르담)을 기준으로 1km반경 내에 보여줄 주차장의 마커 저장 배열 
        
        //Header의 버튼인 Playing..버튼을 누르거나, 사용자 날짜 지정 버튼을 선택하면 XXXInformation에 담긴 정보들이 그에 알맞게 가공된다. XXXInformation의 원본을 저장하는 변수가 tempXXXInformatino이다. 
        var tempMusicalInformation = []; 
        var tempOperaInformation = []; 
        var tempPlayInformation = []; 
        var tempConcertInformation = []; 
        var tempTraditionalArtInformation  = []; 
        var tempClassicInformation = []; 
        var tempExhibitionInformation = [];
        var tempDanceInformation = [];

        var themeCode = []; //테마코드 Json의 item객체 저장해주는 배열
        var performanceThemeCode= []; //현재 사용자가 클릭한 공연의 테마 코드 저장 테마 코드는 문자열로 "1234,5678,1123" 와 같이 4자리 정수가 콤마로 연결된 문자열이다. 예를 들어 테마코드 1234는 themeCode 객체에 담긴 Json정보에서 "즐거움" 이와 같이 매칭됨.
        var cilckMarker; //사용자가 공연 하나를 클릭하면 현재 사용자 눈에 보이는 마커들을 모두 지우고 클릭한 공연의 위치를 나타내는 마커만 지도에 띄움
        var currentMakerLength=0; //현재 화면에 보이는 마커의 개수를 저장해주는 변수
        var infowArray = [] //infoWindow를 담을 객체 선언


        //-------------html의 DOM요소의 객체를 가져오는 부분---------------
        var scrollBar = document.querySelector('#scrollBar');
        var scrollBar_ul = document.querySelector('#scrollBar_ul');
        var idMainTag = document.querySelector('#main');
        var idMain_section1Tag = document.querySelector('#main_section1');
        var headerTag = document.querySelector('#dropdown');
        var footer = document.querySelector('#footer');
        var scrollBar_ul_childCount = document.querySelector('#scrollBar_ul');
        var performanceDetailInformation = document.querySelector('#performanceDetailInformation');
        var checkMusical = document.querySelector('#checkMusical');
        var checkOpera = document.querySelector('#checkOpera');
        var checkPlay = document.querySelector('#checkPlay');
        var checkConcert = document.querySelector('#checkConcert');
        var checkTraditionalArt = document.querySelector('#checkTraditionalArt');
        var checkClassic = document.querySelector('#checkClassic');
        var checkExhibition = document.querySelector('#checkExhibition');
        var checkDance = document.querySelector('#checkDance');
        

        var hiddenbutton = document.querySelector('#ButtonImage');
        var hiddenList = document.getElementById('hiddenList');
        var hiddenList_content = document.getElementById('hiddenList_content');
        var hiddenList_content_ul = document.getElementById('hiddenList_content_ul');
        var nowPlaying = document.querySelector('#nowPlaying');
        var dateDesignation = document.querySelector('#dateDesignation');
        var dataDesignation_send = document.querySelector('#dataDesignation_send');
        var loadingScreen = document.querySelector('#loadingScreen');
        var loadingPercent = document.querySelector('#loadingPercent'); 
        var userInputDateValue;
        
        var naviIcon = document.querySelector('#naviIcon');
        var mapIcon = document.querySelector('#mapIcon');
        var reservationIcon = document.querySelector('#reservationIcon');
       //-------------html의 DOM요소의 객체를 가져오는 부분---------------

        Kakao.init('3f5d2674c29eb3cb86007a28668890f6');//kakao developer에서 발급받은 JavaScript key의 값을 init하여 Kakao API를 사용할 수 있다 

        var mapContainer = document.getElementById('map');
        //화면에 보여질 지도의 Option을 설정하는 단계
        var mapOption = {
            center: new kakao.maps.LatLng(35.13417, 129.11397), // 지도의 중심좌표
              level: 7, // 지도의 확대 레벨
              mapTypeId : kakao.maps.MapTypeId.ROADMAP,
        }; 
        
        // 지도를 생성하여 화면에 띄운다. 
        var map = new kakao.maps.Map(mapContainer, mapOption); 
        var ps = new kakao.maps.services.Places();

        function infowEvent(infoWindow) {infoWindow.close()}
        function showMarkers() {setMarkers(map)}  

        //이 함수는 화면에 마커들을 on/off 해주는 함수로 매개변수로 map이라고 지정하면 on이며 null로 지정하면 off이다. 
        //현재 드롭다운체 check된 공연이 무엇인지 확인하여 if문으로 해당 공연의 마커들을 담고 있는 XXXMarker객체의 setMap함수를 호출하여 마커를 띄워준다. 
        function setMarkers(map) {
            if(checkMusical.checked) {
              for (let i = 0; i < currentMakerLength; i++) {
                musicalMarker[i].setMap(map);
              }  
            }
            else if(checkOpera.checked) {
              for (let i = 0; i < currentMakerLength; i++) {
                operaMarker[i].setMap(map);
              }  
            }
            else if(checkPlay.checked) {
              for (let i = 0; i < currentMakerLength; i++) {
                playMarker[i].setMap(map);
              }  
            } 
            else if(checkConcert.checked) {
              for (let i = 0; i < currentMakerLength; i++) {
                concertMarker[i].setMap(map);
              }  
            }
            else if(checkTraditionalArt.checked) {
              for (let i = 0; i < currentMakerLength; i++) {
                traditionalArtMarker[i].setMap(map);
              }  
            }   
            else if(checkClassic.checked) {
              for (let i = 0; i < currentMakerLength; i++) {
                classicMarker[i].setMap(map);
              }  
            }   
            else if(checkExhibition.checked) {
              for (let i = 0; i < currentMakerLength; i++) {
                exhibitionMarker[i].setMap(map);
              }  
            }   
            else if(checkDance.checked) {
              for (let i = 0; i < currentMakerLength; i++) {
                danceMarker[i].setMap(map);
              }  
            }             
        }

        //두좌표를 km으로 반환
        function getDistanceFromLatLonInKm(lat1, lng1, lat2, lng2) { 
          function deg2rad(deg) { return deg * (Math.PI / 180) } 
          var R = 6371; // Radius of the earth in km 
          var dLat = deg2rad(lat2-lat1); // deg2rad below 
          var dLon = deg2rad(lng2-lng1); 
          var a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2); 
          var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
          var d = R * c; // Distance in km 
          return d; 
        }
       

        //Header에는 Playing.. 버튼과 사용자 날짜 지정 두 버튼이 존재한다. 이 둘은 서로 베타적인 관계로 하나가 on이면 하나는 off이어야한다.
        //만약 Playing 버튼이 on이라면 날짜 지정 버튼은 누를 수 없도록 사용자 눈에서 사라진다. 
        //또한 공연(ex 뮤지컬 중 노트르담) 하나를 클릭하면 상세 보기창이 뜨는데 그때 상단의 두 버튼은 상세 버튼을 끄기 전까지 사라지게 된다.
        //이 처럼 여러 상황에서 Header의 두 버튼이 사라지고 보이고를 해야하는데 이를 수행해주는 함수가 visibleHeaderElement와 hiddenHeaderElement 함수이다. 
        function visibleHeaderElement(str) {
          if(str == 'viewDateOnly') {
            dateDesignation.style.opacity = '1';
            dateDesignation.style.visibility = 'visible';
            dataDesignation_send.style.opacity = '1';
            dataDesignation_send.style.visibility = 'visible';
            dataDesignation_send.value ='확인';
          }
          else if(str=='viewPlayingOnly') {
            nowPlaying.style.opacity = '1';
            nowPlaying.style.visibility = 'visible';
            nowPlaying.firstChild.style.display = 'block';
          }
          else if(str =="ALL") {
            nowPlaying.style.opacity = '1';
            nowPlaying.style.visibility = 'visible';
            nowPlaying.firstChild.style.display = 'block';
            dateDesignation.style.opacity = '1';
            dateDesignation.style.visibility = 'visible';
            dataDesignation_send.style.opacity = '1';
            dataDesignation_send.style.visibility = 'visible';
            dataDesignation_send.value ='확인';
          }
        }

        function hiddenHeaderElement() {
          nowPlaying.style.opacity = '0';
          nowPlaying.style.visibility = 'hidden';
          nowPlaying.firstChild.style.display = 'none';
          dateDesignation.style.opacity = '0';
          dateDesignation.style.visibility = 'hidden';
          dataDesignation_send.style.opacity = '0';
          dataDesignation_send.style.visibility = 'hidden';
          dataDesignation_send.value ='     ';
        }

        //이 함수는 detailScreenEventSet함수 내부에서 실행되는 callee로 공연의 세부 정보창을 클릭했을 때 발생하는 이벤트의 내용이다. 
        function performanceDetailInformation_eventMethod() {
              
              for(let a = 0; a < infowArray.length; a++) {infowArray[a].close();} //infoWindow.close()를 통해 현재 화면에서 사용자가 마커를 클릭하여 공연장이름이 화면에 떠 있는것을 모두 지워준다. 
              if(dataDesignation_send.style.backgroundColor =='rgb(188, 229, 92)') {
                visibleHeaderElement('viewDateOnly');//Header의 playing 버튼과 날짜 버튼 중 날짜 버튼이 on된 경우 날짜 버튼만 보여지게 한다. 
              }
              else if(nowPlaying.style.backgroundColor =='rgb(188, 229, 92)') {
                visibleHeaderElement('viewPlayingOnly');//Header의 playing 버튼과 날짜 버튼 중 playing 버튼이 on된 경우 playing 버튼만 보여지게 한다. 
              }
              else {
                visibleHeaderElement('ALL'); // 둘다 off인 경우 둘다 화면에 보여지게 한다. 
              }

            //상세창이 열려있는 경우 클릭했을 때만 실행되도록 if문으로 감싼다. 상세창이 열려있을 때 다시 누르면 상세창이 꺼지고, 사용자가 클릭한 공연(ex 뮤지컬의 노트르담)의 배경색이 다시 원래대로 돌아오며
            //화면에 다 지워졌던 마커들이 다시 보여져야한다. 
            if(performanceDetailInformation.style.width=='100%') {          
              naviIcon.style.backgroundColor = "#EAEAEA"
              mapIcon.style.backgroundColor = "#EAEAEA"
              reservationIcon.style.backgroundColor = "#EAEAEA"
              while ( performanceDetailInformation.hasChildNodes() ) { performanceDetailInformation.removeChild( performanceDetailInformation.firstChild ); }// 태그 초기화
              //설명창 닫으면 li중 배경 색이 skyblue 이면 skyblue->#EAEAEA로 변경
              for(let i = 0; i < scrollBar_ul_childCount.childElementCount; i++) {
                var color = scrollBar_ul_childCount.children[i].style.backgroundColor;
                if(color == "rgb(96, 63, 131)"  || color == "rgb(250, 208, 201)" || color == "rgb(43, 174, 102)"
                || color == "rgb(242, 170, 76)" || color == "rgb(183, 46, 46)"   || color == "rgb(206, 212, 110)"
                || color == "rgb(41, 171, 226)" || color == "rgb(93, 93, 93)") {
                  scrollBar_ul_childCount.children[i].style.backgroundColor = "#EAEAEA";
                  break;
                }
              }
              showMarkers();
              cilckMarker.setMap(null);
              for(let a = 0; a<clickParkMarker.length; a++) clickParkMarker[a].setMap(null) //주차장 마커 초기화
              performanceDetailInformation.style.width = '0px';
              performanceDetailInformation.style.height = '0px';
              idMainTag.style.height = '85%'; //원래 크기 복구
              idMain_section1Tag.style.height = '100%'; //원래 크기 복구
            }
            
          }

        function detailScreenEventSet() {
          //뮤지컬 상세보기 창 클릭시 이벤트
          performanceDetailInformation.onclick = function() {
            performanceDetailInformation_eventMethod();
          }
        }

        //checkBoxEvent메소드에서 호출되는 callee이다.
        //checkBoxEvent메소드드는 드롭다운에서 8개의 공연중 하나를 클릭했을 때 발생하는 이벤트로 checkBoxEvent_sub_content메소드는 그 일부의 실행 내용이다. 
        function checkBoxEvent_sub_content(performanJson, PerformanceInformation, performaceMaker) {
          let j = 0;
          let temp = [];
          //Playing...버튼을 누른채로 드롭다운 중 뮤지컬을 클릭했을 때 현제 시각 기준 상영하고 있는 뮤지컬 정보만 출력해줌
          if(PerformanceInformation == musicalInformation && nowPlaying.className=='true') {
            for(let i = 0; i <musicalInformation.length; i++) {
              if(musicalInformation[i].op_st_dt <= today) {
                temp[j] = musicalInformation[i]; j++;
              }
            }
            musicalInformation = [...temp];
            showPerformance(musicalInformation, musicalMarker);
          }  
          else if(PerformanceInformation == operaInformation && nowPlaying.className=='true') {
            for(let i = 0; i <operaInformation.length; i++) {
              if( operaInformation[i].op_st_dt <= today) {
                temp[j] = operaInformation[i]; j++;
              }
            }
            operaInformation = [...temp];
            showPerformance(operaInformation, operaMarker);            
          } 
          
          else if(PerformanceInformation == playInformation && nowPlaying.className=='true') {
            for(let i = 0; i <playInformation.length; i++) {
              if( playInformation[i].op_st_dt <= today) {
                temp[j] = playInformation[i]; j++;
              }
            }
            playInformation = [...temp];
            showPerformance(playInformation, playMarker);
          }  
          else if(PerformanceInformation == concertInformation && nowPlaying.className=='true') {
            for(let i = 0; i <concertInformation.length; i++) {
              if( concertInformation[i].op_st_dt <= today) {
                temp[j] = concertInformation[i]; j++;
              }
            }
            concertInformation = [...temp];
            showPerformance(concertInformation, concertMarker);
          } 
          else if(PerformanceInformation == traditionalArtInformation && nowPlaying.className=='true') {
            for(let i = 0; i <traditionalArtInformation.length; i++) {
              if( traditionalArtInformation[i].op_st_dt <= today) {
                temp[j] = traditionalArtInformation[i]; j++;
              }
            }
            traditionalArtInformation = [...temp];
            showPerformance(traditionalArtInformation, traditionalArtMarker);
          } 
          else if(PerformanceInformation == classicInformation && nowPlaying.className=='true') {
            for(let i = 0; i <classicInformation.length; i++) {
              if( classicInformation[i].op_st_dt <= today) {
                temp[j] = classicInformation[i]; j++;
              }
            }
            classicInformation = [...temp];
            showPerformance(classicInformation, classicMarker);
          } 
          else if(PerformanceInformation == exhibitionInformation && nowPlaying.className=='true') {
            for(let i = 0; i <exhibitionInformation.length; i++) {
              if( exhibitionInformation[i].op_st_dt <= today) {
                temp[j] = exhibitionInformation[i]; j++;
              }
            }
            exhibitionInformation = [...temp];
            showPerformance(exhibitionInformation, exhibitionMarker);
          } 
          else if(PerformanceInformation == danceInformation && nowPlaying.className=='true') {
            for(let i = 0; i <danceInformation.length; i++) {
              if( danceInformation[i].op_st_dt <= today) {
                temp[j] = danceInformation[i]; j++;
              }
            }
            danceInformation = [...temp];
            showPerformance(danceInformation, danceMarker);
          } 
          //Playing..버튼이 off이고 사용자 날자 지정 버튼이 on인 경우 드롭다운에서 8개의 공연중 선택하여 변경해도 그대로 사용자가 지정한 날짜에 따라 출력되야한다. 
          else if(dataDesignation_send.className=='true') {callee_callee_dateDesignation_send();} 
          //날짜 지정 버튼,  Playing.. 버튼 둘 다 안 누른 경우 8개의 공연중 하나를 클릭하면 해당 공연의 모든 공연(ex 뮤지컬의 노트르담 등..)이 화면에 출력된다. 
          else {showPerformance(PerformanceInformation, performaceMaker);} 
          
          //드롭다운에서 8개의 공연중 하나를 클릭했으면 드롭다운 메뉴를 닫아주고 Header의 버튼을 화면에 보이게 해준다. 
          hiddenbutton.style.transform="rotate(0deg)";
          hiddenList_content_ul.style.opacity = '0';
          hiddenList.style.width='0%';
          hiddenList_content_ul.style.display = 'none';
          //드롭다운 메뉴를 닫아주고 Header의 버튼을 화면에 보이게 해주는데 사용자가 드롭다운을 클릭하기전 사용자 날짜 지정 버튼만 on된 경우 이 버튼만 화면에 보이게 한다.
          if(dataDesignation_send.style.backgroundColor =='rgb(188, 229, 92)') {
              visibleHeaderElement('viewDateOnly');
          }
          //드롭다운 메뉴를 닫아주고 Header의 버튼을 화면에 보이게 해주는데 사용자가 드롭다운을 클릭하기전 Playing.. 버튼만 on된 경우 이 버튼만 화면에 보이게 한다.
          else if(nowPlaying.style.backgroundColor =='rgb(188, 229, 92)') {
            visibleHeaderElement('viewPlayingOnly');
          }
          //드롭다운 메뉴를 닫아주고 Header의 버튼을 화면에 보이게 해주는데 사용자가 드롭다운을 클릭하기전 두 버튼 다 off된 경우 두 버튼 모두 화면에 보이게 한다.
          else {
            visibleHeaderElement('ALL');
          }
        }

        //이 메소드내부에서는 8개의 공연 버튼을 클릭할 때 발생하는 이벤트를 등록해주는 메소드이다.
        function checkBoxEvent() {
          checkMusical.onclick = function() {
            if(checkMusical.checked) {
              musicalInformation = [...tempMusicalInformation]; //원본인 tempMusicalInformation의 값을 가져옴
              //만약 상세보기 창이 열러있는 상태에서 드롭다운에서 8개의 공연중 하나를 클릭한 경우 상세창을 먼저 닫고 checkBoxEvent_sub_content 함수 호출.
              if(performanceDetailInformation.style.width == '100%') {
                checkBoxEvent_sub_content(musicalJson, musicalInformation, musicalMarker);
                performanceDetailInformation_eventMethod();
              }
              //만약 상세보기 창이 닫힌 상태에서 드롭다운에서 8개 공연 중 하나를 클리하면 그냥 checkBoxEvent_sub_content 함수를 바로 호출.
              else {
                checkBoxEvent_sub_content(musicalJson, musicalInformation, musicalMarker);
              }
              
            }
          }
          checkOpera.onclick = function() {
            if(checkOpera.checked) {
              operaInformation = [...tempOperaInformation]; //원본인 tempOperaInformation 값을 가져옴
              if(performanceDetailInformation.style.width == '100%') {
                checkBoxEvent_sub_content(operaJson, operaInformation, operaMarker);
                performanceDetailInformation_eventMethod();
              }
              else {
                checkBoxEvent_sub_content(operaJson, operaInformation, operaMarker);
              }
              
            }
          }
          checkPlay.onclick = function() {
            if(checkPlay.checked) {
              playInformation = [...tempPlayInformation]; //원본인 tempPlayInformation 값을 가져옴
              if(performanceDetailInformation.style.width == '100%') {
                checkBoxEvent_sub_content(playJson, playInformation, playMarker);
                performanceDetailInformation_eventMethod();
              }
              else {
                checkBoxEvent_sub_content(playJson, playInformation, playMarker);
              }
              
            }
          }

          checkConcert.onclick = function() {
            if(checkConcert.checked) {
              concertInformation = [...tempConcertInformation]; //원본인 tempPlayInformation 값을 가져옴
              if(performanceDetailInformation.style.width == '100%') { 
                checkBoxEvent_sub_content(playJson, concertInformation, concertMarker);
                performanceDetailInformation_eventMethod();
              }
              else {
                checkBoxEvent_sub_content(concertJson, concertInformation, concertMarker); 
              }
            }
          }
          checkTraditionalArt.onclick = function() {
            if(checkTraditionalArt.checked) {
              traditionalArtInformation = [...tempTraditionalArtInformation]; //원본인 tempPlayInformation 값을 가져옴
              if(performanceDetailInformation.style.width == '100%') { 
                checkBoxEvent_sub_content(traditionalArtJson, traditionalArtInformation, traditionalArtMarker);
                performanceDetailInformation_eventMethod();
              }
              else {
                checkBoxEvent_sub_content(traditionalArtJson, traditionalArtInformation, traditionalArtMarker); 
              }
            }
          }
          checkClassic.onclick = function() {
            if(checkClassic.checked) {
              classicInformation = [...tempClassicInformation]; //원본인 tempPlayInformation 값을 가져옴
              if(performanceDetailInformation.style.width == '100%') { 
                checkBoxEvent_sub_content(classicJson, classicInformation, classicMarker);
                performanceDetailInformation_eventMethod();
              }
              else {
                checkBoxEvent_sub_content(classicJson, classicInformation, classicMarker); 
              }
            }
          }
          checkExhibition.onclick = function() {
            if(checkExhibition.checked) {
              exhibitionInformation = [...tempExhibitionInformation]; //원본인 tempPlayInformation 값을 가져옴
              if(performanceDetailInformation.style.width == '100%') { 
                checkBoxEvent_sub_content(exhibitionJson, exhibitionInformation, exhibitionMarker);
                performanceDetailInformation_eventMethod();
              }
              else {
                checkBoxEvent_sub_content(exhibitionJson, exhibitionInformation, exhibitionMarker); 
              }
            }
          }
          checkDance.onclick = function() {
            if(checkDance.checked) {
              danceInformation = [...tempDanceInformation]; //원본인 tempPlayInformation 값을 가져옴
              if(performanceDetailInformation.style.width == '100%') { 
                checkBoxEvent_sub_content(danceJson, danceInformation, danceMarker);
                performanceDetailInformation_eventMethod();
              }
              else {
                checkBoxEvent_sub_content(danceJson, danceInformation, danceMarker); 
              }
            }
          }
        }
        //keywordFilter 메소드를 설명하기 전에 설명할 것이 공연(ex 뮤지컬 노트르담)하나의 객체에는 공연장 이름과 공연장 ID 정보만 저장되어 있다.
        //placeJson에서 '부산 공연장 정보' Json에는 부산의 모든 공연장 이름과 공연장 ID와 해당 공연장의 주소, 위도, 경도 정보가 들어있다. 따라서 공연(ex 뮤지컬 노트르담)하나의 들어있는 공연장 ID를
        //placeJson에서 공연장 ID과 매칭하여 있다면  공연(ex 뮤지컬 노트르담)하나 객체에 프로퍼티를 추가하여 위도, 경도, 주소 값을 복사해서 저장한다. 
        //하지만 매칭이 되지 않는 경우가 발생하는데 이 경우는 kakao 위자들의 sample 코드로 '카카오 키워드 맵 검색'이라는 인터페이스가 있다.  공연(ex 뮤지컬 노트르담)하나의 공연장 이름을 '키워드 검색'을 하게 되면
        //검색 결과와 매칭되는 결과가 여러개 이며 이를 배열로 반환해준다. 따라서 이 여러 검색 결과 중 우리가 찾으려는 공연장을 추출해낼 필요가 있다. 
        //우선 keywordFilter 메소드는 매개변수로 공연(ex 뮤지컬 노트르담)하나 공연장 이름을 매개변수로 지정하면 예를 들어 "MBC드림홀(구, MBC삼주아트홀)"이 원본인데 이 값이 매개변수로 들어가면
        //"MBC드림홀(구, MBC삼주아트홀)" -> "부산 MBC드림홀" 이 문자열로 리턴해준다. 이렇게 하는 이유는 부산을 앞에 붙이면 부산 지역 내로 검색이 되며 괄호는 불필요한 정보가 될 수 있어 제거를 해줘
        //1차적으로 검색결과들의 연관성을 높이기 위한 방법입니다. 
        function keywordFilter(str) {
            var arr = str.split('');//문자별로 분할
            var indexNum;
            for (var i = 0; i < arr.length; i++) {
                if (arr[i] == '(' || arr[i] == '[') { //괄호 검색
                    indexNum = i;//괄호의 인덱스 저장
                }
            }

            var result = arr.join('');
            result = result.substring(0, indexNum);//제일앞부터 괄호앞까지 자르기
            return result; //스트링으로 변환하여 반환

        }

      //키워드 검색 시 원문인 "MBC드림홀(구, MBC삼주아트홀)" 공연장을 keywordFilter메소드를 통해 "부산 MBC드림홀" 이 문자열로 키워드 검색을 하며 상위 2개의 요소를 저장한다. 
      //그리고 검색된 상위 2개의 공연장 이름과 우리가 검색하려는 공연장의 원문인 "MBC드림홀(구, MBC삼주아트홀)" 문자열과 비교하여 같은 true를 리턴하고 true가 리턴되면 
      //그 공연장 정보를 해당 공연(ex 뮤지컬 노트르담)의 공연장 장소로 지정한다. 
      //isSame은 두 str1, str2의 비교 알고리즘으로 str1은 원문이 들어가고, str2는 키워드 검색 결과 문자열이 들어간다. 
      function isSame(str1, str2) {
          var isSame = false;
          if (str1 == str2) {//두 문자열이 완전 일치
              isSame = true;
          }
          else {
              var secondCompareStr1 = keywordFilter(str1).replace(/(\s*)/g, "");
              var secondCompareStr2 = keywordFilter(str2).replace(/(\s*)/g, "");
              if (secondCompareStr1 == secondCompareStr2) {//괄호와 공백을 제거한 두문자열의 일치
                  isSame = true;
              }
              else {
                  var noSpaceStr1 = str1.replace(/(\s*)/g, "");//공백제거
                  var noSpaceStr2 = str2.replace(/(\s*)/g, "");
                  var strArrS = noSpaceStr1.split('');//작은문자열(검사전)
                  var strArrB = noSpaceStr2.split('');//큰문자열(검사전)
                  if (strArrB.length < strArrS.length) {//검사하고 이름에맞게 맞춰줌
                      var temp = strArrS;
                      strArrS = strArrB;
                      strArrB = temp;
                  }
                  if (strArrB == strArrS) {//정제한 문자열이 같으면 true
                      isSame = true;
                  }
                  else {
                      for (var i = 0; i < strArrS.length; i++) {//큰문자열앞부터에 끝까지에 작은문자열이 포함되있는지 검사
                          if (strArrS[i] != strArrB[i]) {//중간에 같지않으면 break하고 false값 반환
                              isSame = false;
                              var forthStr1 = keywordFilter(str1)//괄호및 공백제거
                              forthStr1 = forthStr1.replace(/(\s*)/g, "");

                              var forthStr2 = keywordFilter(str2)
                              forthStr2 = forthStr2.replace(/(\s*)/g, "");

                              forthStr1 = forthStr1.replace("부산", '');//부산 제거
                              forthStr2 = forthStr2.replace("부산", '');
                              if (forthStr1 == forthStr2) {
                                  isSame = true;
                              }
                              else {
                                  isSame = false//분기의 마지막
                              }
                              break;
                          } else {
                              isSame = true;//for문이 도중에 멈추지않았다면 true
                          }
                      }
                  }
              }
          }

          return isSame;
      }//show 배열에따라 마커추가
      
      //공연(ex 뮤지컬 노트르담)하나에는 테마 코드 프로퍼티가 있다. 1234,5678,.. 이와 같은 문자여로 4자리 정수들이 콤바로 구분되어있다. 
      //tcode는 배열로 콤마들을 기준으로 split한 결과가 들어간다.
      //'부산 공연 테마코드' Json은 테마코드에 해당하는 테마가 무엇인지 매칭되어이 있다. (1234 -> "즐거움")
      //isTheme함수는 테마코드를 테마코드 Json의 객체에 매칭하여 1234에 헤댕하는 "즐거움" 이라는 문자열을 반환해준다. 
      //themeCode배열에는 테마코드 Json 정보가 들어있는 객체를 담는 배열이며 객체의 theme 프로퍼티는 1234 와 같은 테마코드이며, theme_nm프로퍼티는 "즐거움"과 같이 그와 매칭되는 테마 문자열이다.
      function isTheme(tCode) {
        for(let i = 0; i < themeCode.length; i++) {
         
          if(tCode == themeCode[i].theme) {
            return themeCode[i].theme_nm;
          }
        }
        return '';
      }

        //이 메소드는 이 앱의 중처적인 역할을 담당하는 메소드로 input은 1번 매개변수로 XXXInformation이 들어가며, 2번 매개변수는 XXXMarder 배열이 들어간다.
        //output으로는 
        function showPerformance(performanceInfor, performaceMaker) {
          //-------------맵에 마커 출력---------------------------------------------------- 
          //기존 마커들 배열에서 모두 제거하고 화면에서 모두 지운다. 즉 마커 정보를 담는 객체를 비우고 화면에 출력된 마커들을 모두 지운다. 
          for (let i = 0; i < musicalMarker.length; i++)  musicalMarker[i].setMap(null);
          for (let i = 0; i < operaMarker.length; i++)  operaMarker[i].setMap(null);
          for (let i = 0; i < playMarker.length; i++)  playMarker[i].setMap(null);
          for (let i = 0; i < concertMarker.length; i++)  concertMarker[i].setMap(null);
          for (let i = 0; i < traditionalArtMarker.length; i++)  traditionalArtMarker[i].setMap(null);
          for (let i = 0; i < classicMarker.length; i++)  classicMarker[i].setMap(null);
          for (let i = 0; i < exhibitionMarker.length; i++)  exhibitionMarker[i].setMap(null);
          for (let i = 0; i < danceMarker.length; i++)  danceMarker[i].setMap(null);

          for(let i =0 ; i<musicalMarker.length; i++) musicalMarker.pop();
          for(let i =0 ; i<operaMarker.length; i++) operaMarker.pop();
          for(let i =0 ; i<playMarker.length; i++) playMarker.pop();
          for(let i =0 ; i<concertMarker.length; i++) concertMarker.pop();
          for(let i =0 ; i<traditionalArtMarker.length; i++) traditionalArtMarker.pop();
          for(let i =0 ; i<classicMarker.length; i++) classicMarker.pop();
          for(let i =0 ; i<exhibitionMarker.length; i++) exhibitionMarker.pop();
          for(let i =0 ; i<danceMarker.length; i++) danceMarker.pop();

          //8개의 공연은 각 마커 색상(마커 이미지)가 지정된다. 
          var imageSrc; 
          if(performanceInfor == musicalInformation) {imageSrc = 'https://mpv990422.duckdns.org/imgs/markerImg/purple.png';}
          else if(performanceInfor == operaInformation){imageSrc = 'https://mpv990422.duckdns.org/imgs/markerImg/pink.png';}
          else if(performanceInfor == playInformation) {imageSrc = 'https://mpv990422.duckdns.org/imgs/markerImg/green.png';}
          else if(performanceInfor == concertInformation) {imageSrc = 'https://mpv990422.duckdns.org/imgs/markerImg/yellow.png';}
          else if(performanceInfor == traditionalArtInformation) {imageSrc = 'https://mpv990422.duckdns.org/imgs/markerImg/red.png';}
          else if(performanceInfor == classicInformation) {imageSrc = 'https://mpv990422.duckdns.org/imgs/markerImg/light_green.png';}
          else if(performanceInfor == exhibitionInformation) {imageSrc = 'https://mpv990422.duckdns.org/imgs/markerImg/skyblue.png';}
          else if(performanceInfor == danceInformation) {imageSrc = 'https://mpv990422.duckdns.org/imgs/markerImg/black.png';}

          
          infowArray =[];//infow 초기화

          // 지도에 마커를 생성하고 표시한다
          let j;
          currentMakerLength=0;
          //공연(ex 뮤지컬 노트르담)에 공연장 주소, 위도, 경도 정보를 저장해주는 for문이다. 
          for(let i=0; i < performanceInfor.length; i++) {
            var placeObject;
            for(j = 0; j < placeInformation.length; j++) {
              if(placeInformation[j].placeId == performanceInfor[i].place_id) {
                placeObject = placeInformation[j];
                //만약 공연(ex 뮤지컬 노트르담)에 해당하는 공연장이 매칭이 된 경우 공연(ex 뮤지컬 노트르담)에 주소, 위도, 경도 정보를 새로운 프로퍼티로 저장한다. 
                performanceInfor[i].lttd = placeObject.lttd;
                performanceInfor[i].lngt = placeObject.lngt;
                performanceInfor[i].addr = placeObject.addr;
                break;
              }
            }
            //만약 매칭이 공연(ex 뮤지컬 노트르담)에 해당하는 공연장이 공연장 Json에 매칭이 안된 경우 카카오맵의 '키워드 검색'을 한다. 
            if(j == placeInformation.length) {
              // 키워드 검색 완료 시 호출되는 콜백함수
                 function placesSearchCB (data, status, pagination) {
                  if (status === kakao.maps.services.Status.OK) {
                      // 검색된 장소 위치를 기준으로 지도 범위를 재설정하기위해
                      // LatLngBounds 객체에 좌표를 추가합니다
                      var bounds = new kakao.maps.LatLngBounds();

                      //검색된 상위 2개 결과를 배열에 넣고 isSame() 함수로 키워드가 같은지 필터링을 한다. 
                      if(isSame(performanceInfor[i].place_nm, data[0].place_name)){
                        displayMarker(data[0]);    
                        bounds.extend(new kakao.maps.LatLng(data[0].y, data[0].x)); //뮤지컬 요소 객체에 위도 경도 추가
                      }
                      else if(data.length >=2 && isSame(performanceInfor[i].place_nm, data[1].place_name)) {
                        displayMarker(data[1]);    
                        bounds.extend(new kakao.maps.LatLng(data[1].y, data[1].x)); //뮤지컬 요소 객체에 위도 경도 추가
                      }
                      else {
                        performanceInfor[i].lttd = "";
                      }      
                  } 
                  //키워드 검색조차도 안 된 경우 아래의 ""빈 값을 저장한다. 이 값인 경우 상세 보기 창을 누르면 alert로 공연장 위치를 조회할 수 없다는 문구를 띄운다. 
                  else {
                    performanceInfor[i].lttd = "";
                  }
              }

              // 지도에 마커를 표시하는 함수입니다
              let displayMarker = function (place) {
                  var imageSize = new kakao.maps.Size(30,40);
                  var imageOption = {offset: new kakao.maps.Point(27, 69)}; // 마커이미지의 옵션입니다. 마커의 좌표와 일치시킬 이미지 안에서의 좌표를 설정합니다.
                  var markerImage = new kakao.maps.MarkerImage(imageSrc, imageSize, imageOption);
                                   
                  // 마커를 생성하고 지도에 표시합니다
                  let marker = new kakao.maps.Marker({
                    position: new kakao.maps.LatLng(place.y, place.x),   
                    image: markerImage
                  });
                  marker.setMap(map);
                  performanceInfor[i].lttd = place.y;
                  performanceInfor[i].lngt = place.x;
                  performanceInfor[i].addr = place.place_name;


                  var infoWindow = new kakao.maps.InfoWindow({
                      content: `Location: ${performanceInfor[i].place_nm}`,
                  });
                  infowArray.push(infoWindow);
                  kakao.maps.event.addListener(marker, "click", function(){infoWindow.open(map, marker)}); 
                  kakao.maps.event.addListener(map, "click", function() {infoWindow.close()});
                
                  performaceMaker[currentMakerLength] = marker;  // 생성된 마커를 배열에 추가합니다
                  currentMakerLength++;
              }
              ps.keywordSearch("부산 "+keywordFilter(performanceInfor[i].place_nm), placesSearchCB);   
            }   
            //공연(ex 뮤지컬 노트르담)에 해당하는 공연장이 매칭이 된 경우 placeObject 변수에 공연장 Json 정보가 담기고 주소, 위도, 경도를 복사해서 
            //공연(ex 뮤지컬 노트르담) 객체에 새로운 프로퍼티로 추가한다. 
            else {
              func();
              function func() {
                var lat = placeObject.lttd; //위도 저장
                var lng = placeObject.lngt; //경도 저장
                    
                var imageSize = new kakao.maps.Size(30,40);
                var imageOption = {offset: new kakao.maps.Point(27, 69)}; // 마커이미지의 옵션입니다. 마커의 좌표와 일치시킬 이미지 안에서의 좌표를 설정합니다.
                var markerImage = new kakao.maps.MarkerImage(imageSrc, imageSize, imageOption);
                var infoWindow = new kakao.maps.InfoWindow({
                    content: `Location: ${performanceInfor[i].place_nm}`,
                });
                infowArray.push(infoWindow);
                    
                // 마커를 생성하고 지도에 표시합니다
                let marker = new kakao.maps.Marker({
                  position: new kakao.maps.LatLng(lat, lng),   
                  image: markerImage
                });
                marker.setMap(map);


                kakao.maps.event.addListener(marker, "click", function(){infoWindow.open(map, marker)});  //마커를 클릭하면 해당 마커의 공연장 정보가 뜨는 이벤트를 등록한다. 
                kakao.maps.event.addListener(map, "click", function(){infoWindow.close()}); //사용자가 map을 클릭하면 화면에 띄워즌 모든 공연장 정보들이 다 꺼진다. 
                
                performaceMaker[currentMakerLength]=marker;  // 생성된 마커를 배열에 추가
                currentMakerLength++;
              }
            }
          }

          function setMarkers(map) {
              for (let i = 0; i < performaceMaker.length; i++) {
                performaceMaker[i].setMap(map);
              }            
          }
          // "마커 감추기" 버튼을 클릭하면 호출되어 배열에 추가된 마커를 지도에서 삭제하는 함수
          function hideMarkers() {
              setMarkers(null);    
          }

          //해당 위도 경도로 맵 위치 이동 
          function setFocusCenter(lt, ln) {
            var movaLatLon = new kakao.maps.LatLng(lt, ln);
            map.setCenter(movaLatLon);
          }

          //----가로 스크롤에 공연 목록 저장-----------------------------
          while ( scrollBar_ul.hasChildNodes() ) { scrollBar_ul.removeChild( scrollBar_ul.firstChild ); }// 가로 스크롤에 저장된 공연들 다 지우기.
          for(let i = 0; i < performanceInfor.length; i++) {
                const li  = document.createElement('li'); //하나의 li태그는 하나의 공연(ex 뮤지컬 노트르담)이다. 
                li.insertAdjacentHTML('beforeend', `${(performanceInfor[i].title)? performanceInfor[i].title:"-"}<br><br>
                ${(performanceInfor[i].op_st_dt)? performanceInfor[i].op_st_dt:"-"} ~ ${(performanceInfor[i].op_ed_dt)? performanceInfor[i].op_ed_dt:"-"}<br><br>
                ${(performanceInfor[i].place_nm)? performanceInfor[i].place_nm:"-"}`);
                scrollBar_ul.appendChild(li);
                li.style.boxShadow = '5px 5px 5px gray';
                li.style.borderRadius = "10px";
                li.style.fontWeight= 'bold';
                
                if(performanceInfor==musicalInformation) {
                  li.style.border = '2px solid #603f83'
                }
                else if(performanceInfor==operaInformation){
                  li.style.border = '2px solid #fad0c9'
                }
                else if(performanceInfor==playInformation){
                  li.style.border = '2px solid #2bae66'
                }
                else if(performanceInfor==concertInformation){
                  li.style.border = '2px solid #f2aa4c'
                }
                else if(performanceInfor==traditionalArtInformation){
                  li.style.border = '2px solid #b72e2e'
                }
                else if(performanceInfor==classicInformation){
                  li.style.border = '2px solid #ced46e'
                }
                else if(performanceInfor==exhibitionInformation){
                  li.style.border = '2px solid #29abe2'
                }
                else if(performanceInfor==danceInformation){
                  li.style.border = '2px solid #5D5D5D'
                }
                li.onclick = function(event) {
                  let c = 0; 
                  console.log('================================');
                  clickPark = [];
                  for(let a = 0; a<clickParkMarker.length; a++) clickParkMarker[a].setMap(null);
                  clickParkMarker = []; //주차장 마커 초기화
                  for(let a = 0; a < infowArray.length; a++) {infowArray[a].close();}//infoWindow.close()로 마커 클릭시 뜨는 알림창 모두 끄기
                  
                  //사용자가 클릭한 공연을 원점으로 1km내의 공영 주차장을 가져옴
                  for(let a = 0; a<totalPark.length; a++) {
                    if(performanceInfor[i].lttd != "") {
                      //현재 공연장을 중심으로 반경 1km내에 있는 경우
                      if(getDistanceFromLatLonInKm(performanceInfor[i].lttd ,performanceInfor[i].lngt, totalPark[a].lttd, totalPark[a].lngt) <= 1) {
                        clickPark[c] = totalPark[a];
                        c++;
                      }
                    }
                  }
                  console.log("현재 클릭한 공연 근처 1km 반경 내의 주차장 개수: "+clickPark.length);
                  

                  //사용자가 공연(ex 뮤지컬 노트르담)하나를 클릭해서 이미 상세창이 뜬 상태에서 다른 li 공연을 클릭 한 경우
                  if(performanceDetailInformation.style.width == '100%') {
                    performanceDetailInformation_eventMethod();
                    hiddenHeaderElement();
                  }
                  if(performanceDetailInformation.style.width == '0px' || performanceDetailInformation.style.width =="") {
                    hiddenHeaderElement();
                    if(performanceInfor==musicalInformation) {event.target.style.backgroundColor = "#603f83";}
                    else if(performanceInfor == operaInformation){event.target.style.backgroundColor = "#fad0c9";}
                    else if(performanceInfor == playInformation) {event.target.style.backgroundColor = "#2bae66";}
                    else if(performanceInfor == concertInformation) {event.target.style.backgroundColor = "#f2aa4c";}

                    else if(performanceInfor == traditionalArtInformation) {event.target.style.backgroundColor = "#b72e2e";}
                    else if(performanceInfor == classicInformation) {event.target.style.backgroundColor = "#ced46e";}
                    else if(performanceInfor == exhibitionInformation) {event.target.style.backgroundColor = "#29abe2";}
                    else if(performanceInfor == danceInformation) {event.target.style.backgroundColor = "#5D5D5D";}
                    
                    //공연(ex 뮤지컬 노트르담)에 해당하는 공연장이 매칭안되고 키워드 검색 결과도 없는 경우 장소를 조회할 수 없다고 알림창을 띄움
                    if( performanceInfor[i].lttd == "") {
                      hideMarkers();
                      alert("장소를 조회할 수 없습니다. \r공연 정보만 표시합니다.");
                    }
                    else {
                      hideMarkers();
                      var clickMarkerImage = 'https://mpv990422.duckdns.org/imgs/markerImg/selMarker.gif', // 공연(ex 뮤지컬 노트르담)하나를 클릭하면 하나의 공연의 마커 이미지
                      clickMarkerParkImage = 'https://mpv990422.duckdns.org/imgs/markerImg/parkMarker.png';
                      imageSize = new kakao.maps.Size(80, 80), // 마커이미지의 크기입니다
                      imageOption = {offset: new kakao.maps.Point(40, 80)}; // 마커이미지의 옵션입니다. 마커의 좌표와 일치시킬 이미지 안에서의 좌표를 설정합니다.
                      // 마커의 이미지정보를 가지고 있는 마커이미지를 생성합니다.

                      let markerImage = new kakao.maps.MarkerImage(clickMarkerImage, imageSize, imageOption),
                          markerPosition = new kakao.maps.LatLng(performanceInfor[i].lttd, performanceInfor[i].lngt); // 마커가 표시될 위치입니다

                      // 마커를 생성합니다
                      cilckMarker = new kakao.maps.Marker({
                          position: markerPosition, 
                          image: markerImage // 마커이미지 설정 
                      });

                      var infoWindow = new kakao.maps.InfoWindow({
                        content: `${performanceInfor[i].place_nm}`,
                      });
                      infowArray.push(infoWindow);
                      kakao.maps.event.addListener(cilckMarker, "click", function(){infoWindow.open(map, cilckMarker)}); 
                      kakao.maps.event.addListener(map, "click", function(){infoWindow.close()});

                      //주차장 마커 화면에 표시
                      for(let i =0; i < clickPark.length;i++) {
                        let parkImageSize = new kakao.maps.Size(30, 40); // 마커이미지의 크기입니다
                        let parkImage = new kakao.maps.MarkerImage(clickMarkerParkImage, parkImageSize, imageOption);
                        let parkPosition = new kakao.maps.LatLng(clickPark[i].lttd, clickPark[i].lngt); // 마커가 표시될 위치입니다

                        // 마커를 생성합니다
                        let ParkMarker = new kakao.maps.Marker({
                            position: parkPosition, 
                            image: parkImage // 마커이미지 설정 
                        });
                        clickParkMarker[i] = ParkMarker;
                        clickParkMarker[i].setMap(map);
                      }
                      //주차장 마커 표시가 끝나면 클릭한 공연장 마커 표시
                      cilckMarker.setMap(map);
                      setFocusCenter(performanceInfor[i].lttd, performanceInfor[i].lngt);
                    }

                    idMainTag.style.height = '115%'; ///80%->115%
                    idMain_section1Tag.style.height = '70%'; ///100%->70%
                    performanceDetailInformation.style.width = '100%';
                    performanceDetailInformation.style.height = '250px';  

                    //상세 보기창에 공연(ex 뮤지컬 노트르담) 상세 정보를 추가해주는 구간
                    for(let i = 0; i < scrollBar_ul_childCount.childElementCount; i++) {
                      var color = scrollBar_ul_childCount.children[i].style.backgroundColor;
                      if(color == "rgb(96, 63, 131)"  || color == "rgb(250, 208, 201)" || color == "rgb(43, 174, 102)"
                      || color == "rgb(242, 170, 76)" || color == "rgb(183, 46, 46)"   || color == "rgb(206, 212, 110)"
                      || color == "rgb(41, 171, 226)" || color == "rgb(93, 93, 93)") {
                       //1101,1001,1110 이와 같은 형태의 테마코드를 즐거움,슬픔,가족 이와 같은 문자열로 변환하기
                       var splitTheme = performanceInfor[i].theme.split(","); //테마코드는 xxxx,xxxx,xxxx 이와 같은 형식으로 jsno에 존재함. 이를 토근으로 분해
                       performanceThemeCode = []; //배열 초기화
                       for(let p = 0; p<splitTheme.length; p++) {
                         if(isTheme(splitTheme[p]) !='') {
                           if(performanceThemeCode =='') {
                            performanceThemeCode = isTheme(splitTheme[p]);
                           }
                           else {
                            performanceThemeCode = performanceThemeCode + ", "+isTheme(splitTheme[p]);
                           }
                         }
                       }
                       
                       //performanceDetailInformation 변수는 상세 보기 창의 DOM 객체이며 상세 정볼르 추가해준다. 삼항 연산자로 만약 프로퍼티가 없다면 "-" 처리한다. 
                        performanceDetailInformation.insertAdjacentHTML('beforeend', 
                      `${(performanceInfor[i].image)? `<img src =${performanceInfor[i].image} width= "100%" height="300px" style="display:block;borderRadius:100%;"><br>` : `<p>Image is loading.  Refresh it later.</p><img style ="margin 0 auto; width:50px; height:50px"src = "http://mpv990422.duckdns.org/imgs/Spinner.gif">`}
                        <h4>Title: </h4>${(performanceInfor[i].title)? performanceInfor[i].title:"-"}<br>
                        <h4>Date: </h4>${(performanceInfor[i].op_st_dt)? performanceInfor[i].op_st_dt:"-"} ~ ${(performanceInfor[i].op_ed_dt)? performanceInfor[i].op_ed_dt:"-"}<br>
                        <h4>Location: </h4>${(performanceInfor[i].place_nm)? performanceInfor[i].place_nm:"-"}<br>
                        <h4>Runtime: </h4>${(performanceInfor[i].runtime)? performanceInfor[i].runtime:"-"}<br>
                        <h4>Showtime: </h4>${(performanceInfor[i].showtime)? performanceInfor[i].showtime:"-"}<br>
                        <h4>Rating: </h4>${(performanceInfor[i].rating)? performanceInfor[i].rating:"-"}<br>
                        <h4>Price: </h4>${(performanceInfor[i].price)? performanceInfor[i].price:"-"}<br>
                        <h4>Theme: </h4>${(performanceThemeCode)? performanceThemeCode:"-"}<br>
                        <h4>Casting: </h4>${(performanceInfor[i].casting)? performanceInfor[i].casting:"-"}<br>
                        <h4>Enterprise: </h4>${(performanceInfor[i].enterprise)? performanceInfor[i].enterprise:"-"}<br>
                        <h4>More Information And Reservation: </h4><a href = "${performanceInfor[i].dabom_url}" target="_blank">${performanceInfor[i].dabom_url}</a><br><br><br>
                        `);
                        break;
                      }
                    }
                  } 
                }
            }      

          //footer 3가지 이벤트 등록
          naviIcon.onclick = function() {
            for(let i = 0; i < scrollBar_ul_childCount.childElementCount; i++) {
              var color = scrollBar_ul_childCount.children[i].style.backgroundColor;
                if(color == "rgb(96, 63, 131)"  || color == "rgb(250, 208, 201)" || color == "rgb(43, 174, 102)"
                || color == "rgb(242, 170, 76)" || color == "rgb(183, 46, 46)"   || color == "rgb(206, 212, 110)"
                || color == "rgb(41, 171, 226)" || color == "rgb(93, 93, 93)") {
                  if(performanceInfor[i].lttd == "") {
                    alert("장소를 조회할 수 없어 네비게이션으로 이동하지 않습니다.\n상세보기란에서 위치를 확인해주세요.");
                    return;
                  }
                  else {
                    naviIcon.style.backgroundColor = "#BCE55C"
                    //카카오 네비 앱을 연동해주며 주소, 위도, 경도 정보를 아래와 같은 형식으로 지정하면 네비 앱으로 전환된다. 
                    Kakao.Navi.start({
                      name: performanceInfor[i].addr,
                      x: Number(performanceInfor[i].lngt),
                      y: Number(performanceInfor[i].lttd),
                      coordType: 'wgs84'
                    });
                    return;
                  }
                } 
            }
            alert(`공연을 선택하세요!`);
          }
        
          mapIcon.onclick = function() {
            for(let i = 0; i < scrollBar_ul_childCount.childElementCount; i++) {
              var color = scrollBar_ul_childCount.children[i].style.backgroundColor;
                if(color == "rgb(96, 63, 131)"  || color == "rgb(250, 208, 201)" || color == "rgb(43, 174, 102)"
                || color == "rgb(242, 170, 76)" || color == "rgb(183, 46, 46)"   || color == "rgb(206, 212, 110)"
                || color == "rgb(41, 171, 226)" || color == "rgb(93, 93, 93)") {
                  if(performanceInfor[i].lttd == "") {
                    alert("장소를 조회할 수 없어 카카오맵으로 이동하지 않습니다.\n상세보기란에서 위치를 확인해주세요.");
                    return;
                  }
                  else {
                    //주소, 위도, 경도 값을 통해 카카오 맵 사이트 (앱이 있다면 앱으로) 연동된다. 
                    mapIcon.style.backgroundColor = "#BCE55C"
                    var url2 = `https://map.kakao.com/link/to/${performanceInfor[i].addr},${performanceInfor[i].lttd},${performanceInfor[i].lngt}`;
                    window.open(url2);
                    return;
                  }
                }
            }
            alert(`공연을 선택하세요!`);
          }

          //공연의 예매 사이트인 다봄 사이트로 전환한다. 
          reservationIcon.onclick = function() {
            for(let i = 0; i < scrollBar_ul_childCount.childElementCount; i++) {
              var color = scrollBar_ul_childCount.children[i].style.backgroundColor;
                if(color == "rgb(96, 63, 131)"  || color == "rgb(250, 208, 201)" || color == "rgb(43, 174, 102)"
                || color == "rgb(242, 170, 76)" || color == "rgb(183, 46, 46)"   || color == "rgb(206, 212, 110)"
                || color == "rgb(41, 171, 226)" || color == "rgb(93, 93, 93)") {
                  reservationIcon.style.backgroundColor = "#BCE55C"
                  window.open(performanceInfor[i].dabom_url);
                  return;
                }
            }
            alert(`공연을 선택하세요!`);
          }
        }

        // 현재 날짜짜를 yyyy-mm-dd 형태의 문자열로 반환한다. 
        function getToday () {
            var date = new Date();
            var year = date.getFullYear();
            var month = ("0" + (1 + date.getMonth())).slice(-2);
            var day = ("0" + date.getDate()).slice(-2);
            return year +'-'+ month +'-' + day;
        }

        //매개변수로 전달된 XXXInformation 공연 객체를 담는 배열을 시간 순서에 따라 정렬해주는 함수 bubble sort 사용 
        function sortDate(arrData) {
            for (var i = arrData.length - 1; i > 0; i--) {
                for (var j = 0; j < i; j++) {
                    if (arrData[j].op_ed_dt > arrData[j + 1].op_ed_dt) {
                        var temp = arrData[j];
                        arrData[j] = arrData[j + 1];
                        arrData[j + 1] = temp;
                    }
                    else if (arrData[j].op_ed_dt == arrData[j + 1].op_ed_dt) {
                        if (arrData[j].op_st_dt > arrData[j + 1].op_st_dt) {
                            var temp = arrData[j];
                            arrData[j] = arrData[j + 1];
                            arrData[j + 1] = temp;
                        }
                    }
                }
            }
            return arrData;
        }
        
        
        detailScreenEventSet(); //상세보기 창 클릭 이벤트 메소드
        checkBoxEvent();        //8개 공연 드롭다운 클릭시 이벤트 메소드
        //---------------공연장 이름, 8가지 공연Json 정보 추출----------------------------------- 
        fetch(place)
        .then(res => res.json())
        .then(resJson => {
            var center = resJson.getBusanCulturePerformPlace.item;
            var totalCount = resJson.getBusanCulturePerformPlace.totalCount;  
            for(let i =0; i<totalCount; i++) {
                placeInformation.push(center[i]); //전체 공연장 정보 {} 객체를 placeInformation에 저장
            }
        });

        fetch(musicalJson)
        .then(res => res.json())
        .then(resJson => {
            var musical = resJson.getBusanCultureMusicalDetail.item;
            var totalCount = resJson.getBusanCultureMusicalDetail.totalCount;
            for(let i = 0; i < totalCount; i++) {
                //현재 시각 기준 공연 예정인 뮤지컬만 추출
                if(musical[i].op_ed_dt >= today) {
                    musicalInformation.push(musical[i]);
                }
            }
            
            sortDate(musicalInformation);
            showPerformance(musicalInformation, musicalMarker);
            //전역 코드의 마지막으로 선언된 비동기 함수가 끝나면 로딩창 끄기
            tempMusicalInformation = [...musicalInformation];
            setPerformance_Information_Image(musicalInformation, "뮤지컬");

            fetch(operaJson)
            .then(res => res.json())
            .then(resJson => {
                var performance;
                var totalCount;
                performance = resJson.getBusanCultureOperaDetail.item;
                totalCount = resJson.getBusanCultureOperaDetail.totalCount;
                for(let i = 0; i<operaInformation.length; i++) operaInformation.pop();
                  let j = 0;
                for(let i = 0; i < totalCount; i++) {
                    //현재 시각 기준 공연 예정인 오페라만 추출
                    if(performance[i].op_ed_dt >= today) {
                      operaInformation[j] = performance[i];
                      j++;
                    }
                }
                sortDate(operaInformation);
                tempOperaInformation = [...operaInformation];
                setPerformance_Information_Image(operaInformation, "오페라");
            });

            fetch(playJson)
            .then(res => res.json())
            .then(resJson => {
                var performance;
                var totalCount;
                performance = resJson.getBusanCulturePlayDetail.item;
                totalCount = resJson.getBusanCulturePlayDetail.totalCount;
                for(let i = 0; i<playInformation.length; i++) playInformation.pop();
                let j = 0;
                for(let i = 0; i < totalCount; i++) {
                    //현재 시각 기준 공연 예정인 연극만 추출
                    if(performance[i].op_ed_dt >= today) {
                      playInformation[j] = performance[i];
                      j++;
                    }
                }
                sortDate(playInformation);
                tempPlayInformation = [...playInformation];
                setPerformance_Information_Image(playInformation, "연극");
            });

            fetch(concertJson)
            .then(res => res.json())
            .then(resJson => {
                var performance;
                var totalCount;
                performance = resJson.getBusanCultureConcertDetail.item;
                totalCount = resJson.getBusanCultureConcertDetail.totalCount;
                for(let i = 0; i<concertInformation.length; i++) concertInformation.pop();
                let j = 0;
                for(let i = 0; i < totalCount; i++) {
                    //현재 시각 기준 공연 예정인 콘서트만 추출
                    if(performance[i].op_ed_dt >= today) {
                      concertInformation[j] = performance[i];
                      j++;
                    }
                }
                sortDate(concertInformation);
                tempConcertInformation = [...concertInformation];
                setPerformance_Information_Image(concertInformation, "콘서트");
            });

            fetch(traditionalArtJson)
            .then(res => res.json())
            .then(resJson => {
                var performance;
                var totalCount;
                performance = resJson.getBusanCultureTraditionDetail.item;
                totalCount = resJson.getBusanCultureTraditionDetail.totalCount;
                for(let i = 0; i<traditionalArtInformation.length; i++) traditionalArtInformation.pop();
                let j = 0;
                for(let i = 0; i < totalCount; i++) {
                    //현재 시각 기준 공연 예정인 전통 무용만 추출
                    if(performance[i].op_ed_dt >= today) {
                      traditionalArtInformation[j] = performance[i];
                      j++;
                    }
                }
                sortDate(traditionalArtInformation);
                tempTraditionalArtInformation = [...traditionalArtInformation];
                setPerformance_Information_Image(traditionalArtInformation, "전통 무용");
            });

            fetch(classicJson)
            .then(res => res.json())
            .then(resJson => {
                var performance;
                var totalCount;
                performance = resJson.getBusanCultureClassicDetail.item;
                totalCount = resJson.getBusanCultureClassicDetail.totalCount;
                for(let i = 0; i<classicInformation.length; i++) classicInformation.pop();
                let j = 0;
                for(let i = 0; i < totalCount; i++) {
                    //현재 시각 기준 공연 예정인 클래식만 추출
                    if(performance[i].op_ed_dt >= today) {
                      classicInformation[j] = performance[i];
                      j++;
                    }
                }
                sortDate(classicInformation);
                tempClassicInformation = [...classicInformation];
                setPerformance_Information_Image(classicInformation, "클래식");
            });

            fetch(exhibitionJson)
            .then(res => res.json())
            .then(resJson => {
                var performance;
                var totalCount;
                performance = resJson.getBusanCultureExhibitDetail.item;
                totalCount = resJson.getBusanCultureExhibitDetail.totalCount;
                for(let i = 0; i<exhibitionInformation.length; i++) exhibitionInformation.pop();
                let j = 0;
                for(let i = 0; i < totalCount; i++) {
                    //현재 시각 기준 공연 예정인 전시만 추출
                    if(performance[i].op_ed_dt >= today) {
                      exhibitionInformation[j] = performance[i];
                      j++;
                    }
                }
                sortDate(exhibitionInformation);
                tempExhibitionInformation = [...exhibitionInformation];
                setPerformance_Information_Image(exhibitionInformation, "전시");
            });

            fetch(danceJson)
            .then(res => res.json())
            .then(resJson => {
                var performance;
                var totalCount;
                performance = resJson.getBusanCultureDanceDetail.item;
                totalCount = resJson.getBusanCultureDanceDetail.totalCount;
                for(let i = 0; i<danceInformation.length; i++) danceInformation.pop();
                let j = 0;
                for(let i = 0; i < totalCount; i++) {
                    //현재 시각 기준 공연 예정인 무용만 추출
                    if(performance[i].op_ed_dt >= today) {
                      danceInformation[j] = performance[i];
                      j++;
                    }
                }
                sortDate(danceInformation);
                tempDanceInformation = [...danceInformation];
                setPerformance_Information_Image(danceInformation, "무용");
            });


            //테마코드 추출
            fetch(themcode)
            .then(res => res.json())
            .then(resJson => {
              var array = resJson.getBusanCultureThemeCode.item;
              var totalCount = resJson.getBusanCultureThemeCode.totalCount;
              for(let i = 0; i<totalCount; i++) {
                themeCode[i] = array[i];
              }
            });

            //부산 공영 주차장 Json 추출
            fetch(parkJson)
            .then(res => res.json())
            .then(resJson => {
              var array = resJson.getPblcPrkngInfo.item;
              var totalCount = resJson.getPblcPrkngInfo.totalCount;
              for(let i = 0; i<totalCount; i++) {
                totalPark[i] = array[i];

                //주차장 Json에서 주차장 가져오기
                function parkSearch(data, status, pagination) {
                  if (status === kakao.maps.services.Status.OK) {
                    totalPark[i].lttd = data[0].y;
                    totalPark[i].lngt = data[0].x;
                  }
                  else {
                    totalPark[i].lttd ="";
                  }
                }
                //카카오 맵에서 "부산 + 공연장명 + 주차장"으로 검색한 결과도 추가하여 반영하기
                ps.keywordSearch(totalPark[i].jibunAddr, parkSearch);
               
              }
            });
        });

        
        //Header의 menu 버튼 클릭시 이벤트 구현
        hiddenbutton.onclick = function() {
          for(let a = 0; a < infowArray.length; a++) {infowArray[a].close();}//infoWindow.close()로 마커 클릭시 뜨는 알림창 모두 끄기
          //드롭다운 창이 닫힌 경우
          if(hiddenList.style.width=="" || hiddenList.style.width=="0%") {
            hiddenbutton.style.transform="rotate(360deg)";
            //hiddenList_content.style.width = '120px';
            hiddenList.style.width='100%';
            setTimeout(()=>{hiddenList_content_ul.style.opacity = '1'}, 300);
            hiddenList_content_ul.style.display = 'block';
            hiddenHeaderElement();
            
          }
          //드롭다운 창이 열린 경우
          else if(hiddenList.style.width=="100%" && hiddenList_content_ul.style.opacity == '1') {
            hiddenbutton.style.transform="rotate(0deg)";
            hiddenList_content_ul.style.opacity = '0';
            hiddenList.style.width='0%';
            hiddenList_content_ul.style.display = 'none'
            if(performanceDetailInformation.style.width !='100%') {
              if(dataDesignation_send.style.backgroundColor =='rgb(188, 229, 92)') {
                visibleHeaderElement('viewDateOnly');
              }
              else if(nowPlaying.style.backgroundColor =='rgb(188, 229, 92)') {
                visibleHeaderElement('viewPlayingOnly');
              }
              else {
                visibleHeaderElement('ALL');
              }
            }
          }
        }
  
        //nowPlaying 메소드에서 호출되는 callee로 클릭시 실행이 구현되는 메소드이다. 
        function callee_nowPlaying() {
          let j = 0;
          let temp = [];
          let nowPerformenceBorderColor = scrollBar_ul_childCount.children[0]; //li태그의 배경색으로 8가지 공연중 어떤 공연인지를 판단한다. 
          if(nowPlaying.firstChild.style.display == 'block') {
              //nowPlaying.className == 'false'인 경우 사용자가 Playing.. 버튼을 on 한 경우 이므로, 현재 상형중인 공연만 보여주기
              if(nowPlaying.className == 'false') {
                nowPlaying.className ='true';
                nowPlaying.style.backgroundColor = '#BCE55C';
                nowPlaying.style.transform="rotate(360deg)";

                if(nowPerformenceBorderColor == null) {
                  musicalInformation = [...temp];
                  showPerformance(musicalInformation, musicalMarker);
                }
                //현재 화면에 보여지는 창이 뮤지커컬인 경우 temp라는 임시 저장소에서 XXXInformation을 가공하여 현재 상영중인 정보만 추출하여 temp에 저장한다. 
                //XXXInformation의 원본은 tempXXXInformation이 가지고 있으므로 XXXInformation을 temp의 값으로 reset 한다. 그리고 showPerformance를 호출한다. 
                else if(nowPerformenceBorderColor.style.borderColor=="rgb(96, 63, 131)") {
                  for(let i = 0; i <musicalInformation.length; i++) {
                    if(musicalInformation[i].op_st_dt <= today) {
                      temp[j] = musicalInformation[i]; j++;
                    }
                  }
                  musicalInformation = [...temp];
                  showPerformance(musicalInformation, musicalMarker);
                }
                else if(nowPerformenceBorderColor.style.borderColor=="rgb(250, 208, 201)") {
                  for(let i = 0; i <operaInformation.length; i++) {
                    if( operaInformation[i].op_st_dt <= today) {
                      temp[j] = operaInformation[i]; j++;
                    }
                  }
                  operaInformation = [...temp];
                  showPerformance(operaInformation, operaMarker);
                }
                else if(nowPerformenceBorderColor.style.borderColor== "rgb(43, 174, 102)"){
                  for(let i = 0; i <playInformation.length; i++) {
                    if( playInformation[i].op_st_dt <= today) {
                      temp[j] = playInformation[i]; j++;
                    }
                  }
                  playInformation = [...temp];
                  showPerformance(playInformation, playMarker);
                }
                else if(nowPerformenceBorderColor.style.borderColor== "rgb(242, 170, 76)"){
                  for(let i = 0; i <concertInformation.length; i++) {
                    if( concertInformation[i].op_st_dt <= today) {
                      temp[j] = concertInformation[i]; j++;
                    }
                  }
                  concertInformation = [...temp];
                  showPerformance(concertInformation, concertMarker);
                }
                else if(nowPerformenceBorderColor.style.borderColor== "rgb(183, 46, 46)"){
                  for(let i = 0; i <traditionalArtInformation.length; i++) {
                    if( traditionalArtInformation[i].op_st_dt <= today) {
                      temp[j] = traditionalArtInformation[i]; j++;
                    }
                  }
                  traditionalArtInformation = [...temp];
                  showPerformance(traditionalArtInformation, traditionalArtMarker);
                }
                else if(nowPerformenceBorderColor.style.borderColor== "rgb(206, 212, 110)"){
                  for(let i = 0; i <classicInformation.length; i++) {
                    if( classicInformation[i].op_st_dt <= today) {
                      temp[j] = classicInformation[i]; j++;
                    }
                  }
                  classicInformation = [...temp];
                  showPerformance(classicInformation, classicMarker);
                }
                else if(nowPerformenceBorderColor.style.borderColor== "rgb(41, 171, 226)"){
                  for(let i = 0; i <exhibitionInformation.length; i++) {
                    if( exhibitionInformation[i].op_st_dt <= today) {
                      temp[j] = exhibitionInformation[i]; j++;
                    }
                  }
                  exhibitionInformation = [...temp];
                  showPerformance(exhibitionInformation, exhibitionMarker);
                }
                else if(nowPerformenceBorderColor.style.borderColor== "rgb(93, 93, 93)"){
                  for(let i = 0; i <danceInformation.length; i++) {
                    if( danceInformation[i].op_st_dt <= today) {
                      temp[j] = danceInformation[i]; j++;
                    }
                  }
                  danceInformation = [...temp];
                  showPerformance(danceInformation, danceMarker);
                }

                dateDesignation.style.opacity = '0';
                dateDesignation.style.visibility = 'hidden';
                dataDesignation_send.style.opacity = '0';
                dataDesignation_send.style.visibility = 'hidden';
                dataDesignation_send.value ='     ';
              }
              //nowPlaying.className == 'true' 인 경우 사용자가 Playing.. 버튼을 off 한 경우 이므로, 다시 원래대로 돌린다. 
              else if(nowPlaying.className == 'true') {
                nowPlaying.className ='false';
                nowPlaying.style.backgroundColor = '#EAEAEA';
                nowPlaying.style.transform="rotate(0deg)";

                //Playing.. 버튼이 off이므로 tempXXXInformation 원본을 다시 불러와 showPerformance를 호출한다. 
                if(checkMusical.checked) {
                  musicalInformation = [...tempMusicalInformation];
                  showPerformance(musicalInformation, musicalMarker);
                }
                else if(checkOpera.checked) {
                  operaInformation = [...tempOperaInformation];
                  showPerformance(operaInformation, operaMarker);
                }
                else if(checkPlay.checked){
                  playInformation = [...tempPlayInformation];
                  showPerformance(playInformation, playMarker);
                }
                else if(checkConcert.checked){
                  concertInformation = [...tempConcertInformation];
                  showPerformance(concertInformation, concertMarker);
                }
                else if(checkTraditionalArt.checked){
                  traditionalArtInformation = [...tempTraditionalArtInformation];
                  showPerformance(traditionalArtInformation, traditionalArtMarker);
                }
                else if(checkClassic.checked){
                  classicInformation = [...tempClassicInformation];
                  showPerformance(classicInformation, classicMarker);
                }
                else if(checkExhibition.checked){
                  exhibitionInformation = [...tempExhibitionInformation];
                  showPerformance(exhibitionInformation, exhibitionMarker);
                }
                else if(checkDance.checked){
                  danceInformation = [...tempDanceInformation];
                  showPerformance(danceInformation, danceMarker);
                }
                dateDesignation.style.opacity = '1';
                dateDesignation.style.visibility = 'visible';
                dataDesignation_send.style.opacity = '1';
                dataDesignation_send.style.visibility = 'visible';
                dataDesignation_send.value ='확인';
              } 
          }
        }
        //Playing.. 버튼 클릭 이벤트
        nowPlaying.onclick = function() {
          for(let a = 0; a < infowArray.length; a++) {infowArray[a].close();}//infoWindow.close()로 마커 클릭시 뜨는 알림창 모두 끄기
          callee_nowPlaying();
        }

        //callee_dateDesignation_send() 에서 호출되는 callee이다. 
        function callee_callee_dateDesignation_send() {
          let j = 0;
          let temp = [];
          //8가지 공연 중 현재 어떤 공연지를 if-else 문으로 구분하여 공연의 날짜가 사용자가 지정한 날짜인 userInputDateValue값 사이에 사영하는 공연을 XXXInformation에서 추출하여
          //temp 에 저장한 뒤 이 값을 XXXInformation의 새로운 값으로 reset한다. 그리고 showPerformace 메소드를 호출한다. 
          if(checkMusical.checked) {
              for(let i = 0; i <musicalInformation.length; i++) {
                if(musicalInformation[i].op_st_dt <= userInputDateValue && musicalInformation[i].op_ed_dt >= userInputDateValue) {
                  temp[j] = musicalInformation[i]; j++;
                }
              }
              musicalInformation = [...temp];
              showPerformance(musicalInformation, musicalMarker);
            }
            else if(checkOpera.checked) {
              for(let i = 0; i <operaInformation.length; i++) {
                if(operaInformation[i].op_st_dt <= userInputDateValue && operaInformation[i].op_ed_dt >= userInputDateValue) {
                  temp[j] = operaInformation[i]; j++;
                }
              }
              operaInformation = [...temp];
              showPerformance(operaInformation, operaMarker);
            }
            else if(checkPlay.checked){
              for(let i = 0; i <playInformation.length; i++) {
                 if(playInformation[i].op_st_dt <= userInputDateValue && playInformation[i].op_ed_dt >= userInputDateValue) {
                  temp[j] = playInformation[i]; j++;
                }
              }
              playInformation = [...temp];
              showPerformance(playInformation, playMarker);
          }
          else if(checkConcert.checked){
              for(let i = 0; i <concertInformation.length; i++) {
                 if(concertInformation[i].op_st_dt <= userInputDateValue && concertInformation[i].op_ed_dt >= userInputDateValue) {
                  temp[j] = concertInformation[i]; j++;
                }
              }
              concertInformation = [...temp];
              showPerformance(concertInformation, concertMarker);
          }
          else if(checkTraditionalArt.checked){
              for(let i = 0; i <traditionalArtInformation.length; i++) {
                 if(traditionalArtInformation[i].op_st_dt <= userInputDateValue && traditionalArtInformation[i].op_ed_dt >= userInputDateValue) {
                  temp[j] = traditionalArtInformation[i]; j++;
                }
              }
              traditionalArtInformation = [...temp];
              showPerformance(traditionalArtInformation, traditionalArtMarker);
          }
          else if(checkClassic.checked){
              for(let i = 0; i <classicInformation.length; i++) {
                 if(classicInformation[i].op_st_dt <= userInputDateValue && classicInformation[i].op_ed_dt >= userInputDateValue) {
                  temp[j] = classicInformation[i]; j++;
                }
              }
              classicInformation = [...temp];
              showPerformance(classicInformation, classicMarker);
          }
          else if(checkExhibition.checked){
              for(let i = 0; i <exhibitionInformation.length; i++) {
                 if(exhibitionInformation[i].op_st_dt <= userInputDateValue && exhibitionInformation[i].op_ed_dt >= userInputDateValue) {
                  temp[j] = exhibitionInformation[i]; j++;
                }
              }
              exhibitionInformation = [...temp];
              showPerformance(exhibitionInformation, exhibitionMarker);
          }
          else if(checkDance.checked){
              for(let i = 0; i <danceInformation.length; i++) {
                 if(danceInformation[i].op_st_dt <= userInputDateValue && danceInformation[i].op_ed_dt >= userInputDateValue) {
                  temp[j] = danceInformation[i]; j++;
                }
              }
              danceInformation = [...temp];
              showPerformance(danceInformation, danceMarker);
          }
        }

        //dataDesignation_send() 에서 호출되는 callee이다. 
        function callee_dataDesignation_send() {
          let j = 0;
          let temp = [];
          if(dataDesignation_send.value == "확인") {
              //현재 상형중인 공연만 보여주는 버튼이 on되는 경우이다.
              if(dataDesignation_send.className == 'false') {
                //각종 에니메이션이 진행된 후 callee_callee_dateDesignation_send가 호출된다. 
                dataDesignation_send.className ='true';
                dataDesignation_send.style.backgroundColor = '#BCE55C';
                dataDesignation_send.className ='true';
                dateDesignation.style.backgroundColor = '#BCE55C';
                nowPlaying.style.opacity = '0';
                nowPlaying.style.visibility = 'hidden';
                nowPlaying.firstChild.style.display = 'none';
                
                callee_callee_dateDesignation_send();
              }
              //현재 상형중인 공연만 보여주는 버튼이 off되는 경우이다. 이는 사용자 날짜 지정 공연 추출에서 다시 원래대로 돌리게 된다. 
              else if(dataDesignation_send.className == 'true') {
                dataDesignation_send.className ='false';
                dateDesignation.style.backgroundColor = '#EAEAEA';
                dataDesignation_send.style.backgroundColor = '#EAEAEA';
                nowPlaying.style.opacity = '1';
                nowPlaying.style.visibility = 'visible';
                nowPlaying.firstChild.style.display = 'block';

                //XXXInformation의 값을 원본 객체의 값으로 돌리고 showPerformance를 호출한다. 
                if(checkMusical.checked) {
                  musicalInformation = [...tempMusicalInformation];
                  showPerformance(musicalInformation, musicalMarker);
                }
                else if(checkOpera.checked) {
                  operaInformation = [...tempOperaInformation];
                  showPerformance(operaInformation, operaMarker);
                }
                else if(checkPlay.checked){
                  playInformation = [...tempPlayInformation];
                  showPerformance(playInformation, playMarker);
                }
                else if(checkConcert.checked){
                  concertInformation = [...tempConcertInformation];
                  showPerformance(concertInformation, concertMarker);
                }
                else if(checkTraditionalArt.checked){
                  traditionalArtInformation = [...tempTraditionalArtInformation];
                  showPerformance(traditionalArtInformation, traditionalArtMarker);
                }
                else if(checkClassic.checked){
                  classicInformation = [...tempClassicInformation];
                  showPerformance(classicInformation, classicMarker);
                }
                else if(checkExhibition.checked){
                  exhibitionInformation = [...tempExhibitionInformation];
                  showPerformance(exhibitionInformation, exhibitionMarker);
                }
                else if(checkDance.checked){
                  danceInformation = [...tempDanceInformation];
                  showPerformance(danceInformation, danceMarker);
                }
                dateDesignation.style.opacity = '1';
                dateDesignation.style.visibility = 'visible';
                dataDesignation_send.style.opacity = '1';
                dataDesignation_send.style.visibility = 'visible';
                dataDesignation_send.value ='확인';
              } 
          }
        }

        //날짜 입력 버튼을 클릭했을 때 발생하는 이벤트
        dateDesignation.value = today;
        dataDesignation_send.onclick = function() {
          for(let a = 0; a < infowArray.length; a++) {infowArray[a].close();}//infoWindow.close()로 마커 클릭시 뜨는 알림창 모두 끄기
          userInputDateValue = dateDesignation.value;
          callee_dataDesignation_send();
        }

        //setPerformance_Information_Image() 에서 호출되는 callee이다. 
        //이 메소드는 공연(ex 뮤지컬 노트르담)에 해당하는 다봄 사이트에서 공연 이미지를 크롤링 하여 이미지를 가져오는 메소드이다. 
        //callee에서는 이미지 크롤링이 진행된다. 첫 매개변수는 XXXInformation이 들어간다. XXXInformation이.image라는 프로퍼티에 크롤링르 통해 이미지의 URL 주소를 저장한다. 
        //len 매개변수는 현재 XXXInformation의 배열의 index이다. 
        // InformationString은 8가지 공연에 대한 "뮤지컬", "연극".. 등 문자열을 지정해주는 매개밴수이다.
        function callee_setPerformance_Information_Image(performanceInformation, len, InformationString) {
            const proxy = 'https://busan-show.herokuapp.com/';
            var request = new XMLHttpRequest();
            request.open("GET", proxy + performanceInformation.dabom_url);
            request.responseType = "document";
            request.onload = function () {
              if (request.readyState === 4) {
                if (request.status === 200) {
                  var imgElement = request.responseXML.querySelector("div.leftbox>img");
                  var imgUrl = imgElement.src;
                  var splitUrl = imgUrl.split('/')
                  imgUrl = 'http://busandabom.net/images/contents/' + splitUrl[5]
                  if (splitUrl[5] == "noimg_classic.jpg") {
                    imgUrl = 'http://busandabom.net/img/content/' + splitUrl[5]
                  }
                  //다봄 사이트 크롤링을 통해 얻어진 이미지 URL을 XXXInformation.image의 값으로 저장한다. 
                  performanceInformation.image = imgUrl;
                  loadginEnd(InformationString, len);
                } else {
                  console.error(request.status, request.statusText);
                }
              }
            };
            request.onerror = function (e) {
              console.error(request.status, request.statusText);
            };
            request.send(null);  // not a POST request, so don't send extra data
            //8개 공연중 처음으로 뮤지컬을 fetch하는데 뮤지컬 공연 정보 배열 요소에 image의 삽입이 모두 끝나면 호출되는 함수로 이때 로딩창 이미지를 꺼준다.          
        }

        function setPerformance_Information_Image(performanceInformation, InformationString) {
          for(let i=0; i < performanceInformation.length; i++) {
            callee_setPerformance_Information_Image(performanceInformation[i], i, InformationString);
          }
        }

        //앱 접속시 로딩창이 뜨고 로딩이 끝나면 로딩창을 꺼주는 함수
        function loadginEnd(InformationString, len) {
          if((len +1)==musicalInformation.length) {
            loadingPercent.textContent=`Loading Images 100%`;
          }
          else {
            loadingPercent.textContent=`Loading Images ${parseInt(((len)/musicalInformation.length)*100)}%`;
          }
          
          if(InformationString==="뮤지컬" && ((len +1)==musicalInformation.length)) {
            console.log('뮤지컬 이미지 로딩 끝');
            loadingScreen.style.display='none';
            footer.style.display = 'block';
            headerTag.style.display='block';
          }
        }
 </script>
 </body>
 </html>   
 
 